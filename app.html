<!DOCTYPE html>
<html>
  <head>
    <title>AR.js A-Frame Location-based</title>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script
      type="text/javascript"
      src="https://raw.githack.com/AR-js-org/AR.js/master/three.js/build/ar-threex-location-only.js"
    ></script>
    <script
      type="text/javascript"
      src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"
    ></script>
  </head>

  <body>
    <a-scene
      vr-mode-ui="enabled: false"
      arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false;"
      renderer="antialias: true; alpha: true"
    >
      <a-camera look-controls-enabled='true' arjs-device-orientation-controls='smoothingFactor: 0.1' gps-new-camera="gpsMinDistance: 2" rotation-reader></a-camera>

      <script>
        window.onload = function () {
          const routeData = JSON.parse(localStorage.getItem("routeData"));
          console.log("Start Location:", routeData.startLocation);
          console.log("End Location:", routeData.endLocation);

          function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of the Earth in kilometers
            const dLat = (lat2 - lat1) * (Math.PI / 180);
            const dLon = (lon2 - lon1) * (Math.PI / 180);
            const a =
              Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(lat1 * (Math.PI / 180)) *
                Math.cos(lat2 * (Math.PI / 180)) *
                Math.sin(dLon / 2) *
                Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c * 1000; // Convert distance to meters
            return distance;
          }
          function calculateDirectionAndRotation(start, end) {
  const directionVector = {
    x: end.location[1] - start.location[1],
    y: end.location[0] - start.location[0],
    z: 0, // Assuming a 2D plane
  };

  // Normalize direction vector
  const length = Math.sqrt(
    directionVector.x ** 2 + directionVector.y ** 2 + directionVector.z ** 2
  );
  directionVector.x /= length;
  directionVector.y /= length;
  directionVector.z /= length;

  // Calculate rotation based on direction vector
  const rotationX = Math.atan2(directionVector.z, directionVector.y); // Calculate rotation in X direction
  const rotationY = Math.atan2(directionVector.x, directionVector.y); // Calculate rotation in Y direction

  return { rotationX, rotationY };
}

          function updateSpheresSize(position) {
            routeData.detailedRouteDetails.forEach((step, index) => {
              step.intersections.forEach((intersection, i) => {
                const distance = calculateDistance(
                  position.latitude,
                  position.longitude,
                  intersection.location[1],
                  intersection.location[0]
                );

                // const poiEntity = document.querySelector(`[gps-entity-place="latitude: ${intersection.location[1]}; longitude: ${intersection.location[0]"}]`);
                const poiEntity = document.createElement("a-entity");

                poiEntity.setAttribute("gps-new-entity-place", {
                  latitude: intersection.location[1],
                  longitude: intersection.location[0],
                });

                poiEntity.setAttribute(
                  "gltf-model",
                  "url(./assets/models/arrowNew.glb)"
                );
                if(i < step.intersections.length - 1)
                {
                  const nextIntersection = step.intersections[i + 1];  
                  const { rotationX, rotationY } = calculateDirectionAndRotation(intersection, nextIntersection);
                   // Set rotation based on calculated direction
                  const rotationXDeg = THREE.MathUtils.radToDeg(rotationX);
                  const rotationYDeg = THREE.MathUtils.radToDeg(rotationY);
                  poiEntity.setAttribute("rotation", `${rotationXDeg} ${rotationYDeg} 0`);
                }
                else if (i === step.intersections.length - 1 && index === routeData.detailedRouteDetails.length - 1) {
                  const { rotationX, rotationY } = calculateDirectionAndRotation(
                    { latitude: intersection.location[1], longitude: intersection.location[0] },
                    { latitude: routeData.endLocation[1], longitude: routeData.endLocation[0] }
                  );
                  const rotationXDeg = THREE.MathUtils.radToDeg(rotationX);
                  const rotationYDeg = THREE.MathUtils.radToDeg(rotationY);
                  poiEntity.setAttribute("rotation", `${rotationXDeg} ${rotationYDeg} 0`);
                }
                document.querySelector("a-scene").appendChild(poiEntity);
                // Only render spheres within a certain radius (e.g., 20 meters)
                
                if (distance <= 20) {
                  poiEntity.setAttribute("visible", "true");
                } else {
                  poiEntity.setAttribute("visible", "false");
                }

                // Calculate and add marker for midpoint
                if (i < step.intersections.length - 1) {
                  const nextIntersection = step.intersections[i + 1];
                  const midpointLat =
                    (intersection.location[1] + nextIntersection.location[1]) /
                    2;
                  const midpointLon =
                    (intersection.location[0] + nextIntersection.location[0]) /
                    2;

                  const midpointEntity = document.createElement("a-entity");
                  midpointEntity.setAttribute("gps-new-entity-place", {
                    latitude: midpointLat,
                    longitude: midpointLon,
                  });
                  midpointEntity.setAttribute(
                    "gltf-model",
                    "url(./assets/models/arrowNew.glb)"
                  );
                  const { rotationX1, rotationY1 } = calculateDirectionAndRotation(
                    { latitude: midpointLat, longitude: midpointLon },
                    { latitude: nextIntersection.location[1], longitude: nextIntersection.location[0] }
                  );
                  const rotationXDeg1 = THREE.MathUtils.radToDeg(rotationX1);
                  const rotationYDeg1 = THREE.MathUtils.radToDeg(rotationY1);

                  midpointEntity.setAttribute("rotation", `${rotationXDeg1} ${rotationYDeg1} 0`);

                  // Only render midpoint marker within a certain radius (e.g., 20 meters)
                  const midpointDistance = calculateDistance(
                    position.latitude,
                    position.longitude,
                    midpointLat,
                    midpointLon
                  );
                  if (midpointDistance <= 20) {
                    midpointEntity.setAttribute("visible", "true");
                  } else {
                    midpointEntity.setAttribute("visible", "false");
                  }

                  document.querySelector("a-scene").appendChild(midpointEntity);
                }
              });
            });
          }
          // Create midpoint entity for the startLocation and the first intersection
          //       const startToFirstMidpointEntity = document.createElement("a-entity");
          //      const startToFirstMidpointLat = (routeData.startLocation[1] + routeData.detailedRouteDetails[0].intersections[0].location[1]) / 2;
          //         const startToFirstMidpointLat = (routeData.startLocation[0] + routeData.detailedRouteDetails[0].intersections[0].location[0]) / 2;
          //               startToFirstMidpointEntity.setAttribute("gps-new-entity-place", { latitude: startToFirstMidpointLat, longitude: startToFirstMidpointLon });
          //        startToFirstMidpointEntity.setAttribute("gltf-model", "url(./assets/models/arrowNew.glb)");

          //                // Set rotation for the start to first midpoint to look at the first intersection
          //                   const startToFirstMidpointRotation = calculateRotation(
          //       { latitude: startToFirstMidpointLat, longitude: startToFirstMidpointLon },
          //             { latitude: routeData.detailedRouteDetails[0].intersections[0].location[1], longitude: routeData.detailedRouteDetails[0].intersections[0].location[0] }
          //          );
          //      startToFirstMidpointEntity.setAttribute("rotation", `0 ${startToFirstMidpointRotation} 0`);
          // const startDistance = calculateDistance(
          //           position.latitude,
          //           position.longitude,
          //           startToFirstMidpointLat,
          //           startToFirstMidpointLat
          //         );
          //         if (startDistance <= 20) {
          //           startToFirstMidpointEntity.setAttribute("visible", "true");
          //         } else {
          //           startToFirstMidpointEntity.setAttribute("visible", "false");
          //         }

          //    document.querySelector("a-scene").appendChild(startToFirstMidpointEntity);

          //          // Create midpoint entity for the endLocation and the last intersection
          //      const lastToFinalMidpointEntity = document.createElement("a-entity");
          //   const lastToFinalMidpointLat = (routeData.endLocation[1] + routeData.detailedRouteDetails[routeData.detailedRouteDetails.length - 1].intersections[routeData.detailedRouteDetails[routeData.detailedRouteDetails.length - 1].intersections.length - 1].location[1]) / 2;
          //  const lastToFinalMidpointLon = (routeData.endLocation[0] + routeData.detailedRouteDetails[routeData.detailedRouteDetails.length - 1].intersections[routeData.detailedRouteDetails[routeData.detailedRouteDetails.length - 1].intersections.length - 1].location[0]) / 2;
          //  lastToFinalMidpointEntity.setAttribute("gps-new-entity-place", { latitude: lastToFinalMidpointLat, longitude: lastToFinalMidpointLon });
          //     lastToFinalMidpointEntity.setAttribute("gltf-model", "url(./assets/models/arrowNew.glb)");

          //    // Set rotation for the last to final midpoint to look at the last intersection
          //      const lastToFinalMidpointRotation = calculateRotation(
          //       { latitude: lastToFinalMidpointLat, longitude: lastToFinalMidpointLon },
          //          { latitude: routeData.detailedRouteDetails[routeData.detailedRouteDetails.length - 1].intersections[routeData.detailedRouteDetails[routeData.detailedRouteDetails.length - 1].intersections.length - 1].location[1], longitude: routeData.detailedRouteDetails[routeData.detailedRouteDetails.length - 1].intersections[routeData.detailedRouteDetails[routeData.detailedRouteDetails.length - 1].intersections.length - 1].location[0] }
          //      );
          // lastToFinalMidpointEntity.setAttribute("rotation", `0 ${lastToFinalMidpointRotation} 0`);
          
          // document.querySelector("a-scene").appendChild(lastToFinalMidpointEntity);
          
          document
            .querySelector("[gps-new-camera='gpsMinDistance: 2']")
            .addEventListener("gps-camera-update-position", (e) => {
              // When the camera's position updates, update the size of the spheres
              updateSpheresSize(e.detail.position);
            });

          const iEntity = document.createElement("a-entity");

          iEntity.setAttribute("gps-new-entity-place", {
            latitude: routeData.startLocation[1],
            longitude: routeData.startLocation[0],
          });

           iEntity.setAttribute(
                  "gltf-model",
                  "url(./assets/models/map_pointer_3d_icon.glb)"
          );

          document.querySelector("a-scene").appendChild(iEntity);

          const eEntity = document.createElement("a-entity");

          eEntity.setAttribute("gps-new-entity-place", {
            latitude: routeData.endLocation[1],
            longitude: routeData.endLocation[0],
          });
          eEntity.setAttribute(
                  "gltf-model",
                  "url(./assets/models/map_pointer_3d_icon.glb)"
          );
          document.querySelector("a-scene").appendChild(eEntity);
        };
      </script>
    </a-scene>
  </body>
</html>
