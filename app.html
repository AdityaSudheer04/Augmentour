<!DOCTYPE html>
<html>

<head>
  <title>AR.js A-Frame Location-based</title>
  <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
  <script type='text/javascript' src='https://raw.githack.com/AR-js-org/AR.js/master/three.js/build/ar-threex-location-only.js'></script>
  <script type='text/javascript' src='https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js'></script>
</head>

<body>
  <a-scene vr-mode-ui="enabled: false" arjs='sourceType: webcam; videoTexture: true; debugUIEnabled: false;'
    renderer='antialias: true; alpha: true'>
    <a-camera gps-camera rotation-reader></a-camera>

    <script>
      window.onload = function () {
        const routeData = JSON.parse(localStorage.getItem('routeData'));
        console.log('Start Location:', routeData.startLocation);
        console.log('End Location:', routeData.endLocation);

        function calculateDistance(lat1, lon1, lat2, lon2) {
          const R = 6371; // Radius of the Earth in kilometers
          const dLat = (lat2 - lat1) * (Math.PI / 180);
          const dLon = (lon2 - lon1) * (Math.PI / 180);
          const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          const distance = R * c * 1000; // Convert distance to meters
          return distance;
        }

        function createSphere(color, scale, latitude, longitude, visible) {
          const sphere = document.createElement('a-sphere');
          sphere.setAttribute('color', color);
          sphere.setAttribute('scale', scale);
          sphere.setAttribute('gps-entity-place', `latitude: ${latitude}; longitude: ${longitude}`);
          sphere.setAttribute('visible', visible); // Set visibility initially
          document.querySelector('a-scene').appendChild(sphere);
          return sphere;
        }

        function updateSpheresVisibility(position) {
          routeData.detailedRouteDetails.forEach((step, index) => {
            step.intersections.forEach((intersection, i) => {
              // Check distance for initial spheres
              const distance = calculateDistance(position.coords.latitude, position.coords.longitude, intersection.location[1], intersection.location[0]);

              // Check distance for newly created spheres
              for (let j = 1; j <= 5; j++) {
                const fraction = j / 6; // Divide the distance into 6 parts (5 intervals)
                const avgLatitude = intersection.location[1] + fraction * (step.intersections[i + 1].location[1] - intersection.location[1]);
                const avgLongitude = intersection.location[0] + fraction * (step.intersections[i + 1].location[0] - intersection.location[0]);
                const newSphere = document.querySelector(`[gps-entity-place="latitude: ${avgLatitude}; longitude: ${avgLongitude}"]`);

                if (newSphere) {
                  const newDistance = calculateDistance(position.coords.latitude, position.coords.longitude, avgLatitude, avgLongitude);
                  newSphere.setAttribute('visible', newDistance <= 100);
                }
              }

              // Toggle visibility for initial spheres based on distance
              const isVisible = distance <= 100;
              const sphere = document.querySelector(`[gps-entity-place="latitude: ${intersection.location[1]}; longitude: ${intersection.location[0]}"]`);

              if (sphere) {
                sphere.setAttribute('visible', isVisible);
              }
            });
          });
        }

        document.querySelector("[gps-camera]").addEventListener("gps-camera-update-position", (e) => {
          // When the camera's position updates, update the visibility of the spheres
          updateSpheresVisibility(e.detail.position);
        });

        // Create spheres initially
        routeData.detailedRouteDetails.forEach((step, index) => {
          step.intersections.forEach((intersection, i) => {
            // Only create spheres within a certain radius initially
            const distance = calculateDistance(routeData.startLocation[1], routeData.startLocation[0], intersection.location[1], intersection.location[0]);
            createSphere('red', '5 5 5', intersection.location[1], intersection.location[0], true);

            // Create additional spheres between existing intersections
            for (let j = 1; j <= 5; j++) {
              const fraction = j / 6; // Divide the distance into 6 parts (5 intervals)
              const avgLatitude = intersection.location[1] + fraction * (step.intersections[i + 1].location[1] - intersection.location[1]);
              const avgLongitude = intersection.location[0] + fraction * (step.intersections[i + 1].location[0] - intersection.location[0]);
              createSphere('green', '5 5 5', avgLatitude, avgLongitude, true);
            }
          });
        });

        // Create spheres for starting and ending locations without 5-meter visibility policy
        createSphere('blue', '5 5 5', routeData.startLocation[1], routeData.startLocation[0], true);
        createSphere('blue', '5 5 5', routeData.endLocation[1], routeData.endLocation[0], true);
      };
    </script>
  </a-scene>
</body>

</html>
