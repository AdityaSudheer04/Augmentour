<!DOCTYPE html>
<html>
  <head>
    <title>AR.js A-Frame Location-based</title>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script
      type="text/javascript"
      src="https://raw.githack.com/AR-js-org/AR.js/master/three.js/build/ar-threex-location-only.js"
    ></script>
    <script
      type="text/javascript"
      src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"
    ></script>
  </head>

  <body>
    <a-scene
      vr-mode-ui="enabled: false"
      arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false;"
      renderer="antialias: true; alpha: true"
    >
      <a-camera look-controls-enabled='true' arjs-device-orientation-controls='smoothingFactor: 0.1' gps-new-camera="gpsMinDistance: 2" rotation-reader></a-camera>

      <script>
        window.onload = function () {
          const routeData = JSON.parse(localStorage.getItem("routeData"));
          console.log("Start Location:", routeData.startLocation);
          console.log("End Location:", routeData.endLocation);     
          let prev;
          function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of the Earth in kilometers
            const dLat = (lat2 - lat1) * (Math.PI / 180);
            const dLon = (lon2 - lon1) * (Math.PI / 180);
            const a =
              Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(lat1 * (Math.PI / 180)) *
                Math.cos(lat2 * (Math.PI / 180)) *
                Math.sin(dLon / 2) *
                Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c * 1000 ; // Convert distance to meters
            return distance;
          }
          // function calculateRotation(start, end) {
          //   const dLat = end.latitude - start.latitude;
          //   const dLon = end.longitude - start.longitude;
          //   return (Math.atan2(dLon, dLat) * 180) / Math.PI;
          // }
          function calculateRotation(start, end) {
      const dLat = end.latitude - start.latitude;
      const dLon = end.longitude - start.longitude;
      // Calculate the rotation angle in radians
      const rotationAngle = Math.atan2(dLon, dLat);
      // Convert the rotation angle to degrees
      const rotationDegrees = (rotationAngle * 180) / Math.PI;
      // Adjust the rotation to ensure it's between 0 and 360 degrees
      return (rotationDegrees + 360) % 360;
    }

          function calculateDirectionVector(start, end) {
      const dLat = end.latitude - start.latitude;
      const dLon = end.longitude - start.longitude;
      const length = Math.sqrt(dLat * dLat + dLon * dLon);

      // Normalize the direction vector
      const direction = {
        x: dLat / length,
        y: dLon / length,
      };

      return direction;
    }
          function updateSpheresSize(position) {
                const intersectionsArray = [];
          routeData.detailedRouteDetails.forEach((step, index) => {
            step.intersections.forEach((intersection, i) => {
              intersectionsArray.push({
                latitude: intersection.location[1],
                longitude: intersection.location[0],
                instruction: step.instruction,
                speechdistance: step.distance,
              });
            });
          });
          intersectionsArray.forEach((intersection, i) => {
              const distance = calculateDistance(
                  position.latitude,
                  position.longitude,
                  intersection.latitude,
                  intersection.longitude
                );
                const poiEntity = document.createElement("a-entity");
                poiEntity.setAttribute("gps-new-entity-place", {
                  latitude: intersection.latitude,
                  longitude: intersection.longitude,
                });
               if (
                  !((intersection.latitude === routeData.startLocation[1] && intersection.longitude === routeData.startLocation[0]) ||
                  (intersection.latitude === routeData.endLocation[1] && intersection.longitude === routeData.endLocation[0]))
              ) {
                 poiEntity.setAttribute(
                  "gltf-model",
                  "url(./assets/models/arrowNew.glb)"
                );
              }
                if(i < intersectionsArray.length - 2)
                {
                  const nextIntersection = intersectionsArray[i + 1];  
                  const directionVector= calculateDirectionVector(
                    { latitude: intersection.latitude, longitude: intersection.longitude },
                    { latitude: nextIntersection.latitude, longitude: nextIntersection.longitude }
                  );
                  const rotationY = Math.atan2(directionVector.x, directionVector.y) * (180 / Math.PI);
                   poiEntity.setAttribute("rotation", `0 ${rotationY} 0`);
                }
                else if (i === intersectionsArray.length - 2) {
                  const directionVector = calculateDirectionVector(
                    { latitude: intersection.latitude, longitude: intersection.longitude },
                    { latitude: routeData.endLocation[1], longitude: routeData.endLocation[0] }
                  );
                  const rotationEnd = Math.atan2(directionVector.x, directionVector.y) * (180 / Math.PI);
                  poiEntity.setAttribute("rotation", `0 ${rotationEnd} 0`);
                }
                if (distance <= 20) {
                  if(intersection.instruction !== prev && intersection.instruction)
                  {
                  if(intersection.speechdistance==0)
                  {
                    speakInstruction(intersection.instruction);
                  }
                  else
                  {  
                    if(instruction.toLowerCase().startsWith('turn'))
                    {
                    speakInstruction(intersection.instruction+"And Walk For another"+Math.floor(intersection.speechdistance)+"meters");
                    }
                    else
                    {
                     speakInstruction(intersection.instruction+"For another"+Math.floor(intersection.speechdistance)+"meters");
                    }
                  }
                  }
                  if(intersection.instruction)
                  {
                  prev = intersection.instruction;
                  }
                  poiEntity.setAttribute("visible", "true");
                  document.querySelector("a-scene").appendChild(poiEntity);
                } else {
                  poiEntity.setAttribute("visible", "false");
                }

            if (i < intersectionsArray.length - 1) {
                const nextIntersection = intersectionsArray[i + 1];

                const diffLatitudes = Math.abs(
                  intersection.latitude - nextIntersection.latitude
                );
                const diffLongitudes = Math.abs(
                  intersection.longitude - nextIntersection.longitude
                );

                const segmentLength = 10; // Set the length of each segment

                const numMidpoints = Math.floor(
                  calculateDistance(
                    intersection.latitude,
                    intersection.longitude,
                    nextIntersection.latitude,
                    nextIntersection.longitude
                  ) / segmentLength
                );

                for (let j = 1; j <= numMidpoints; j++) {
                  const ratio = j / (numMidpoints + 1);

                  const midpointLat =
                    intersection.latitude +
                    ratio * diffLatitudes;
                  const midpointLon =
                    intersection.longitude +
                    ratio * diffLongitudes;

                  const midpointEntity = document.createElement("a-entity");
                  midpointEntity.setAttribute("gps-new-entity-place", {
                    latitude: midpointLat,
                    longitude: midpointLon,
                  });
                  midpointEntity.setAttribute(
                    "gltf-model",
                    "url(./assets/models/arrowNew.glb)"
                  );

                  const directionVectorMidpoint = calculateDirectionVector(
                    {
                      latitude: midpointLat,
                      longitude: midpointLon,
                    },
                    {
                      latitude: nextIntersection.latitude,
                      longitude: nextIntersection.longitude,
                    }
                  );

                  const rotationMidpoint =
                    Math.atan2(directionVectorMidpoint.x, directionVectorMidpoint.y) *
                    (180 / Math.PI);
                  midpointEntity.setAttribute("rotation", `0 ${rotationMidpoint} 0`);

                  const midpointDistance = calculateDistance(
                    position.latitude,
                    position.longitude,
                    midpointLat,
                    midpointLon
                  );

                  if (midpointDistance <= 20) {
                    midpointEntity.setAttribute("visible", "true");
                    document.querySelector("a-scene").appendChild(midpointEntity);
                  } else {
                    midpointEntity.setAttribute("visible", "false");
                  }
                }
              }
                
            
            });
          }
          document
            .querySelector("[gps-new-camera='gpsMinDistance: 2']")
            .addEventListener("gps-camera-update-position", (e) => {
              // When the camera's position updates, update the size of the spheres
              updateSpheresSize(e.detail.position);
            });

          const iEntity = document.createElement("a-entity");

          iEntity.setAttribute("gps-new-entity-place", {
            latitude: routeData.startLocation[1],
            longitude: routeData.startLocation[0],
          });

           iEntity.setAttribute(
                  "gltf-model",
                  "url(./assets/models/map_pointer_3d_icon.glb)"
          );

          document.querySelector("a-scene").appendChild(iEntity);

          const eEntity = document.createElement("a-entity");

          eEntity.setAttribute("gps-new-entity-place", {
            latitude: routeData.endLocation[1],
            longitude: routeData.endLocation[0],
          });
          eEntity.setAttribute(
                  "gltf-model",
                  "url(./assets/models/map_pointer_3d_icon.glb)"
          );
          document.querySelector("a-scene").appendChild(eEntity);
          function speakInstruction(instruction) {
            const msg = new SpeechSynthesisUtterance();
            msg.text = instruction;
            window.speechSynthesis.speak(msg);
          }
        };
      </script>
    </a-scene>
  </body>
</html>
