<!DOCTYPE html>
<html>
  <head>
    <title>AR.js A-Frame Location-based</title>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script
      type="text/javascript"
      src="https://raw.githack.com/AR-js-org/AR.js/master/three.js/build/ar-threex-location-only.js"
    ></script>
    <script
      type="text/javascript"
      src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"
    ></script>
  </head>

  <body>
    <a-scene
      vr-mode-ui="enabled: false"
      arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false;"
      renderer="antialias: true; alpha: true"
    >
      <a-camera look-controls-enabled='false' arjs-device-orientation-controls='smoothingFactor: 0.1' gps-new-camera="gpsMinDistance: 2" rotation-reader></a-camera>

      <script>
        window.onload = function () {
          const routeData = JSON.parse(localStorage.getItem("routeData"));
          console.log("Start Location:", routeData.startLocation);
          console.log("End Location:", routeData.endLocation);

          function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of the Earth in kilometers
            const dLat = (lat2 - lat1) * (Math.PI / 180);
            const dLon = (lon2 - lon1) * (Math.PI / 180);
            const a =
              Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(lat1 * (Math.PI / 180)) *
                Math.cos(lat2 * (Math.PI / 180)) *
                Math.sin(dLon / 2) *
                Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c * 1000; // Convert distance to meters
            return distance;
          }

          function updateSpheresSize(position) {
    const allIntersections = [];

    // Iterate over the detailedRouteDetails array to generate midpoint markers
    routeData.detailedRouteDetails.forEach((step, i) => {
      const intersection = {
        latitude: step.intersections[0].location[1],
        longitude: step.intersections[0].location[0],
      };

      // Add the current intersection to the allIntersections array
      allIntersections.push(intersection);

      // Calculate and add marker for midpoint (except for the last intersection)
      if (i < routeData.detailedRouteDetails.length - 1) {
        const nextIntersection = routeData.detailedRouteDetails[i + 1].intersections[0];
        const midpointLat = (intersection.latitude + nextIntersection.location[1]) / 2;
        const midpointLon = (intersection.longitude + nextIntersection.location[0]) / 2;

        // Add the midpoint to the allIntersections array
        const midpoint = {
          latitude: midpointLat,
          longitude: midpointLon,
        };
        allIntersections.push(midpoint);
      }
    });
     const firstIntersection = routeData.detailedRouteDetails[0].intersections[0];
  const startMidpointLat = (firstIntersection.location[1] + routeData.startLocation[1]) / 2;
  const startMidpointLon = (firstIntersection.location[0] + routeData.startLocation[0]) / 2;
  const startMidpoint = {
    latitude: startMidpointLat,
    longitude: startMidpointLon,
  };
  allIntersections.push(startMidpoint);
    // Iterate over the allIntersections array to generate markers
    allIntersections.forEach((intersection, i) => {
      const distance = calculateDistance(
        position.latitude,
        position.longitude,
        intersection.latitude,
        intersection.longitude
      );

      const poiEntity = document.createElement("a-entity");
      poiEntity.setAttribute("gps-new-entity-place", {
        latitude: intersection.latitude,
        longitude: intersection.longitude,
      });
      poiEntity.setAttribute("gltf-model", {
  url: "./assets/models/arrow.glb",
  scale: "20 20 20", 
});

      document.querySelector("a-scene").appendChild(poiEntity);

      // Only render spheres within a certain radius (e.g., 1000 meters)
      if (distance <= 1000) {
        poiEntity.setAttribute("visible", "true");
      } else {
        poiEntity.setAttribute("visible", "false");
      }
    });
  }
          
          document
            .querySelector("[gps-new-camera='gpsMinDistance: 2']")
            .addEventListener("gps-camera-update-position", (e) => {
              // When the camera's position updates, update the size of the spheres
              updateSpheresSize(e.detail.position);
            });

          const iEntity = document.createElement("a-entity");

          iEntity.setAttribute("gps-new-entity-place", {
            latitude: routeData.startLocation[1],
            longitude: routeData.startLocation[0],
          });

          iEntity.setAttribute("geometry", {
            primitive: "sphere",
            radius: 5,
          });

          iEntity.setAttribute("material", "color:blue");

          document.querySelector("a-scene").appendChild(iEntity);

          const eEntity = document.createElement("a-entity");

          eEntity.setAttribute("gps-new-entity-place", {
            latitude: routeData.endLocation[1],
            longitude: routeData.endLocation[0],
          });

          eEntity.setAttribute("geometry", {
            primitive: "sphere",
            radius: 5,
          });

          eEntity.setAttribute("material", "color:blue");

          document.querySelector("a-scene").appendChild(eEntity);
        };
      </script>
    </a-scene>
  </body>
</html>
