<!DOCTYPE html>
<html>

<head>
  <title>AR.js A-Frame Location-based</title>
  <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
  <script type='text/javascript' src='https://raw.githack.com/AR-js-org/AR.js/master/three.js/build/ar-threex-location-only.js'></script>
  <script type='text/javascript' src='https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js'></script>
  <script src="https://rawgit.com/nicolocarpignoli/nicolocarpignoli.github.io/master/ar-click-events/events.js"></script>
</head>

<body>
  <a-scene vr-mode-ui="enabled: false" arjs='sourceType: webcam; videoTexture: true; debugUIEnabled: false;'
    renderer='antialias: true; alpha: true'>
    <a-camera gps-camera rotation-reader></a-camera>

    <script>
      window.onload = function () {
        let testEntityAdded = false;
        const el = document.querySelector("a-camera");

        el.addEventListener("gps-camera-update-position", e => {
          if (!testEntityAdded) {
            alert(`Got first GPS position: lon ${e.detail.position.longitude} lat ${e.detail.position.latitude}`);

            const routeData = JSON.parse(localStorage.getItem('routeData'));
            console.log('Start Location:', routeData.startLocation);
            console.log('End Location:', routeData.endLocation);

            function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of the Earth in kilometers
            const dLat = (lat2 - lat1) * (Math.PI / 180);
            const dLon = (lon2 - lon1) * (Math.PI / 180);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
              Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c * 1000; // Convert distance to meters
            return distance;
          }
            function createBox(color, scale, latitude, longitude) {
              const box = document.createElement('a-box');
              box.setAttribute('color', color);
              box.setAttribute('scale', scale);
              box.setAttribute('gps-entity-place', `latitude: ${latitude}; longitude: ${longitude}`);
              document.querySelector('a-scene').appendChild(box);
              return box;
            }

            routeData.detailedRouteDetails.forEach((step, index) => {
              step.intersections.forEach((intersection, i) => {
                const box = createBox('red', '10 10 10', intersection.location[1], intersection.location[0]);

                navigator.geolocation.watchPosition((position) => {
                  const userLat = position.coords.latitude;
                  const userLon = position.coords.longitude;
                  const distance = calculateDistance(userLat, userLon, intersection.location[1], intersection.location[0]);

                  if (distance <= 10) {
                    box.setAttribute('visible', true);
                  } else {
                    box.setAttribute('visible', false);
                  }
                });
              });
            });

            createBox('blue', '10 10 10', routeData.startLocation[1], routeData.startLocation[0]);
            createBox('blue', '10 10 10', routeData.endLocation[1], routeData.endLocation[0]);

            testEntityAdded = true;
          }
        });

        setInterval(() => {
          testEntityAdded = false;
        }, 3000); // Reset the flag every 3 seconds to allow re-evaluation of proximity
      };
    </script>
  </a-scene>
</body>

</html>
